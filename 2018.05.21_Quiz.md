## 리소스를 불러올 때 리소스의 출처가 웹 페이지의 출처와 같으면 안전하고, 출처가 다르면 해당 리소스는 안전하지 않다고 보는 원칙은?

> 정답 : 동일 출처 정책

<br>

## 다음 중 보안과 관련된 설명으로 틀린 것은?

1.  '출처'란 프로토콜 + 도메인 + 포트번호의 결합이며, 셋 중 하나라도 다르면 동일 출처로 간주되지 않는다.<br>

2.  `window.open()` 메소드를 통해 새로 연 탭 또는 창의 웹페이지가 이전 웹 페이지와 동일 출처의 주소라면,<br>
    `window.opener`를 통해 이전 웹 페이지의 전역 객체에 접근해 수정할 수 있다.<br>

3.  클라이언트 측 기법 중 `Content-Security-Policy` HTTP 헤더를 이용해 동일하지 않은 출처에 대한 리소스를 불러올지 말지 결정할 수 있다.

4.  CORS(Cross-Origin Resource Sharing)는 클라이언트 측 cross-origin 요청을 안전하게 보낼 수 있는 방법을 정한 표준이다.

5.  CORS(Cross-Origin Resource Sharing) 표준은 웹 브라우저가 사용하는 정보를 읽을 수 있도록<br>
    허가된 출처 집합를 서버에게 알려주도록 허용하는 HTTP 헤더를 추가함으로써 동작한다.<br>

> 정답 : 3, 5 번

서버에서 제공하는 모든 것 을 맹목적으로 신뢰하는 대신,<br>
CSP 는 신뢰할 수 있는 콘텐츠 소스의 허용 목록을 생성할 수 있게 해주는<br>
Content-Security-Policy HTTP 헤더를 정의하고<br>
브라우저에는 이런 소스에서 받은 리소스만 실행하거나 렌더링할 것을 지시하는 서버측 기술이다.<br>

<br>

## POST, PUT, PATCH, DELETE 등의 메소드는 요청이 서버에 전송되는 것 자체가 위험하다.실제 요청 보내기 전 서버가 cross-origin 요청을 허용하는지 알아보기 위해 시험적으로 요청을 한 번 보내보는데 이때 이 요청은?

1.  Access-Control-Request
2.  Preflighted request
3.  XMLHttpRequest

> 정답 : 2 번

<br>

## 다음 중 토큰과 쿠기에 대한 설명으로 틀린 것은?

1.  쿠키는 지원하는 클라이언트(웹 브라우저)에서 밖에 사용할 수 없다.
2.  적절히 관리되지 않은 쿠키는 보안에 취약하다. 관리를 하려 해도 CORS 대응이 복잡하다.
3.  토큰이란 사용자의 자격증명을 통해 인증이 이루어진 후, 특정 자원데 대한 자격증명으로서 대신 사용되는 인증 수단이다.
4.  서버에 요청을 할 때 한번만 토큰을 요청에 포함시켜서 전송한다. 주로 Authorization 헤더에 넣어서 전송한다.
5.  토큰을 사용하면 다양한 인증 수단(전화번호, 공인인증서, 생체 정보 등)의 인증 결과를 토큰이라는 하나의 수단으로 통일할 수 있다.

> 정답 : 4 번

<br>

## Web Storage 에 대한 설명으로 틀린것은?

1.  브라우저에서 키 -값 쌍을 저장할 수 있는 저장소이다.
2.  브라우저 탭이 닫히면 내용이 삭제되는 Web Storage 로는 sessionStorage 가 있다.
3.  localStorage 는 브라우저 탭이 닫혀도 내용이 유지된다.
4.  10MB 가량 저장할 수 있는 쿠키에 비하면 4000 바이트로 저장 가능한 용량이 작다는 단점이 있다.
5.  토큰을 localStorage 에 저장하게 되면 자바스크립트로 토큰을 탈취할 수 있게 되므로, 웹사이트에 악성 스크립트를 삽입하는 공격(XSS)에 노출되지 않도록 신경써야한다.

> 정답 : 4 번

<br>

## 최근 널리 사용되고 있는 토큰 형식의 표준이며, 토큰 안에 JSON 형식으로 정보를 저장하는 이 방식은?

> 정답 : JSON Web Token (JWT)

<br>

## 웹 브라우저의 XMLHttpRequest 를 대체하기 위해 만들어진 새로운 HTTP client 표준은? (비교적 최근에 도입되어 IE 및 구형 안드로이드 브라우저(4.x)는 지원하지 않는다. )

> 정답 : Fetch API

<br>

## 캐시된 자원과 실제 자원의 내용이 달라지는 문제를 해결하기 위한 방식에 대한 내용으로 틀린 것은?

1.  Expiration(만료) : 정해진 시간이 지나면 캐시가 자동으로 삭제되도록 설정한다.
2.  Validation(검증): 서버에 요청을 보내 캐시를 계속 사용할 수 있는지 확인한다.
3.  Expiration 보다 Validation 의 방식이 통신 트래픽이 줄어들고 속도 개선에 도움을 준다.
4.  업데이트가 계속 이뤄지는 자원일 경우 Validation 방식이 유용하다.
5.  Expiration 은 사본과 원본이 달라지는 시점이 생긴다.

> 정답 : 3 번

<br>

## 자원의 버전을 검증하기 위해 유일하게 식별할 수 있는 문자열, 주로 자원의 해시값이 사용되거나 마지막으로 수정된 시각, 혹은 버전 넘버를 사용하기도 하는 Cache 관련 헤더 중 가장 많이 사용되는 헤더는?

> 정답 : ETag

<br>

## 각각의 자원마다 경로가 따로 있어 여러 자원이 동시에 필요한 경우에는 요청을 여러 번 보내야 한다거나, 자원의 필요한 속성만 얻어올 수 없다는 단점이 있는 REST API 의 단점을 대체하기 위해 2015 년 Facebook 에서 공개한 데이터 질의 언어는?

> 정답 : GraphQL

<br>

## 컴퓨터 분야에서 데이터를 미리 복사해 놓는 임시저장소, 또는 임시저장소에 데이터를 저장하는 행위를 가리키는 것은?

> 정답 : Cache

<br>

## CORS 에 대한 설명으로 옳지 않은 것은?

1.  cross-origin 요청에는 쿠키를 포함할 수 없다.
2.  클라이언트 측 요청을 안전하게 보낼 수 있는 방법을 정한 표준
3.  cross-origin 요청을 허용하려면, 서버가 특별한 형태의 응답을 전송해야 함
4.  리소스의 출처가 다를면 해당 리소스가 안전하지 않다고 보는 원칙을 동일 출처 정책이라 한다.

> 정답 : 1 번

<br>

## 토큰에 대한 설명으로 옳지 않은 것은?

1.  쿠키와는 다르게, 클라이언트 개발자가 직접 토큰을 저장하고 관리 해야 함
2.  적절히 관리 되지 않으면, 보안에 취약하며, 관리를 하려고 해도 CORS 대응이 복잡함
3.  다양한 인증 수단의 인증 결과를 하나의 수단으로 통일 할 수 있다.
4.  매 요청에 포함되게 됨으로 적당히 짧은 길이를 유지 해야 함.

> 정답 : 2 번

2 번] 쿠키에 관련된 설명입니다.

<br>

## 특정 메소드는 요청이 서버에 전송되는 것 자체가 위험하므로, 실제 요청을 보내기 전에 서버가 cross-origin 요청을 허용하는지를 알아보기 위해 시험적으로 요청을 한 번 보내본다. 이 요청을 preflighted request 라 하는데, 이 요청이 발생하지 않는 메소드는?

1.  PUT
2.  PATCH
3.  DELETE
4.  multipart/form-data 형태의 POST
5.  XML 페이로드를 전송한 POST

> 정답 : 4 번

1] GET, HEAD 외의 메서드를 사용하는 경우<br>
<br>

2] POST 메서드를 사용한 요청이 application/x-www-form-urlencoded, multipart/form-data, or text/plain<br>
이외의 다른 값을 가진 Content-Type 과 함께 요청 데이터를 전송하는데 사용된 경우<br>
<br>

3] POST 요청이 서버에 application/xml 혹은 text/xml 을 사용하여 XML 페이로드를 전송하게 되면, 요청은 사전 전달됩니다.

<br>

## Web Storage 에 관한 설명으로 옳지 않은 것은?

1.  브라우저에서 키-값 쌍을 저장할 수 있는 저장소
2.  쿠키에 비해 사용하기 편리하고 저장 가능한 용량도 크다.
3.  sessionStorage 는 탭이 닫혀도 내용이 유지 된다.
4.  토큰을 localStorage 에 저장하게 되면 토큰을 탈취할 수 있게 되므로 유의 해야 한다.

> 정답 : 3 번

브라우저 탭이 닫히면 내용이 삭제되는 sessionStorage,<br>
브라우저 탭이 닫혀도 내용이 유지되는 localStrage 가 있습니다.

<br>

## 캐쉬 자원과 실제 자원의 검증을 통해 자원의 변경이 되지 않았다면 서버는 304 응답을 반환한다.

> 정답 : O

클라이언트는 'If-None-Match' HTTP 요청 헤더 내에서 ETag 토큰을 자동으로 제공합니다.<br>
서버는 현재 자원과 비교하여 이 토큰을 검사합니다.<br>
토큰이 변경되지 않은 경우, 서버는 '304 Not Modified' 응답을 반환합니다.<br>
이 응답은 캐시에 저장된 응답이 변경되지 않았고 추가로 120 초 동안<br>
갱신될 수 있음을 브라우저에 알립니다.<br>

<br>

## 임의의 길이를 갖는 임의의 데이터에 대해 고정된 길이의 데이터로 매핑하는 함수를 뜻하는 용어는?

> 정답 : hash

<br>

## 캐시의 검증을 위해 사용되는 자원의 식별자로써 if-none-match 헤더의 값으로 포함되는 것은?

> 정답 : ETag

<br>

## REST API 에 대한 설명으로 옳지 않은 것은?

1.  여러 자원이 동시에 필요한 경우 요청을 여러번 보내야 한다.
2.  자원의 필요한 속성만 얻어 올 수 없다.
3.  요청의 효율성을 위해 일부 속성만 가져올 수 있다.
4.  각각의 자원마다 경로가 따로 지정되어 있다.

> 정답 : 3 번

자원의 필요한 속성만 얻어 올수 없다.<br>
일부속성이 필요하더라도 전체 속성을 가져와야 한다.

<br>

## Facebook 에서 2015 년 공개한 데이터 질의 언어로, 클라이언트에서 필요한 데이터의 구조를 정의한 후 질의할 수 있고, 서버는 그에 맞게 구조화된 데이터를 응답할수 있는 언어는?

> 정답 : GraphQL

<br>

## 다음 중 Same-origin Policy (동일 출처 정책)에 대해 옳은 것은?

1.  좋은 정책이지만 아직은 웹 브라우저의 많은 요소에 적용되지 못했습니다.
2.  출처란 프로토콜 + 도메인 + ip 주소의 결합을 가리킵니다.
3.  리소스의 출처와 웹페이지의 출처가 달라도 보안프로그램이 깔려있으면 안전하다고 판단합니다.
4.  출처 중에 하나라도 다르면 동일 출처로 간주되지 않습니다.

> 정답 : 4 번

1 번) 리소스의 출처와 웹페이지의 출처가 다를 경우 해당 리소스는 안전하지 않다고 판단합니다.<br>
2 번) 웹 보안의 기본 원칙으로, 웹 브라우저의 많은 요소에 적용되었습니다.<br>
3 번) 출처란 '프로토콜 + 도메인 + 포트번호'의 결합을 의미합니다.<br>

<br>

## 다음 중 CORS 의 특징으로 옳은 것은?

1.  서버측 요청을 안전하게 보낼 수 있는 표준입니다.
2.  스크립트가 전혀 다른 API 서버를 사용하려고 하는 상황에서는 뭔가 추가적인 처리를 해주어야 합니다
3.  클라이언트 측 cross-origin 요청을 보낼 수 있으나 보안적으로 안전하지 않습니다.
4.  리소스를 공유하는 것임으로 안전하지 못합니다.

> 정답 : 2 번

1 번) 서버측 요청이 아닌 클라이언트 측의 요청을 안전하게 보낼수 있는 표준입니다.<br>
2 번) 리소스를 공유함으로써 요청을 안전하게 주고 받을 수 있습니다.<br>
4 번) 보안적으로 안전합니다.

<br>

## 쿠키에 대한 올바른 설명을 모두 고르시오

1.  쿠키는 지원하는 클라이언트 서버에서밖에는 사용할 수 없습니다.
2.  쿠키는 로컬 서버에 저장됩니다
3.  적절히 관리되지 않은 쿠키는 보안에 취약합니다.
4.  적절히 관리를 한다면 CORS 대응이 간편합니다.
5.  쿠키를 쓰는 것이 토큰을 쓰는 것보다 CORS 관련 문제를 회피하기에 용이합니다.

> 정답 : 1, 3 번

2 번) 쿠키는 클라이언트 쪽(웹 브라우저)에 저장됩니다.<br>
4 번) 쿠키는 적절히 관리를 하여도 CORS 대응이 까다롭습니다.<br>
5 번) 토큰을 쓰는 것이 쿠키를 쓰는 것보다 CORS 관련 문제를 회피하기 좋습니다.

<br>

## 토큰의 설명에 대한 것으로 옳지 않은 것을 모두 고르시오

1.  매 요청에 토큰이 포함되므로 보안성을 위해 토큰의 길이는 길어야 합니다.
2.  쿠키를 지원하지 않는 클라이언트에서도 편하게 사용할 수 있습니다.
3.  토큰은 해시값으로 구성되어 있으므로 보완성이 좋아서 유출되어도 해독할 수 없으므로 대비책을 안새워도 됩니다.
4.  쿠키와 동일하게 클라이언트 개발자가 직접 저장 및 관리를 할 필요가 없습니다.
5.  다양한 인증 수단의 결과를 토큰이라는 하나의 수단으로 통일할 수 있습니다.

> 정답 : 1, 4, 5 번

1 번) 매 요청에 토큰이 포함되므로 적당히 짧은 길이를 유지해야합니다.<br>
3 번) 토큰은 인증의 결과물이여서 탈취당할 경우 다양한 범죄에 노출될 수 있으므로<br>
토큰 유출에 대해 대비책이 필요합니다. (유효기간 및 강제 무효화등...)<br>
4 번) 쿠키와는 다르게 토큰은 클라이언트 개발자가 직접 토큰을 저장하고 관리해야 합니다.

<br>

## 토큰을 사용할 때는 HTTP 를 사용해야 한다?

> 정답 : X

토큰은 정말 민감한 정보이기 때문에 해킹으로부터 보안을 유지해야함으로,<br>
HTTPS 를 사용해야합니다.

<br>

## HTTP Cache 는 브라우저에 상관없이 캐시를 어떻게 할 것인지에 대해 결정하는 규칙이 통일되어 있다?

> 정답 : X

HTTP Cache

* 자원의 효율적 로딩을 위한 웹 표준입니다.
* 서버에서 가져온 자원(HTML, CSS, JS, 이미지, ...)을 가까운 곳(브라우저, 혹은 다른 서버)에 저장해놓고 재사용합니다.
* 캐시를 할 것인지 말 것인지, 어떻게 할 것인지를 결정하는 규칙이 복잡하고, 브라우저마다 조금씩 다릅니다.

<br>

## Fetch API 에 대한 설명으로 옳은 것은?

1.  비교적 최근에 도입되었음에도 불구하고 IE 및 구형 안드로이드 브라우저(4.x)까지 지원합니다.
2.  웹 브라우저의 XMLHttpRequest 를 대체하기 위해 만들어진 새로운 HTTP client 표준입니다.
3.  service worker 를 사용할 예정에 있는 프로젝트에는 fetch 보다 axios 를 사용하는 것이 효율적입니다.
4.  사용법이 난해하여 구형 브라우저를 지원할 경우 Fetch API 보다 XMLHttpRequest 를 사용하는 것이 좋습니다.

> 정답 : 2 번

1 번) 비교적 최근에 도입되었기에 IE 및 구형 안드로이드 브라우저(4.x)는 지원하지 않습니다.<br>
3 번) service worker 를 사용할 예정에 있는 프로젝트에는 axios 보다 fetch 를 사용하는 것이 효율적입니다.<br>
(service worker 에서 XMLHttpRequest 를 지원하지 않기 때문입니다)<br>
4 번) 말도 안되는 소리입니다

<br>

## Web Storage 의 종류로 브라우저 탭이 닫혀도 내용이 유지되는 것은 무엇일까요?

> 정답 : localStorage

Web Storage

* 브라우저에서 키-값 쌍을 저장할 수 있는 저장소
* 쿠키에 비해 사용하기 편리하고 저장 가능한 용량도 큽니다.(10MB 가량)
* 브라우저 탭이 닫히면 내용이 삭제되는 sessionStorage(임시 저장소)
* 브라우저 탭이 닫혀도 내용이 유지되는 localStorage 가 있습니다.

<br>

## Facebook 에서 2015 년 공개한 데이터 질의 언어로 REST API 를 대체하기 위해 만들어진 이 것은 무엇일까요?

> 정답 : GraphQL

* Facebook 에서 2015 년 공개한 데이터 질의 언어입니다.
* REST API 를 대체하기 위해 만들어졌습니다.
* 클라이언트에서 필요한 데이터의 구조를 GraphQL 언어로 정의한 후 질의할 수 있고, 서버는 그에 맞게 구조화된 데이터를 응답합니다.
* 서버에서는 GraphQL 질의를 해석하기 위해 별도의 해석기가 필요하며, 여러 언어의 구현체가 나와있는 상태입니다.

<br>

## Cache 의 관련 해더로 캐시의 검증을 위해 사용되는 자원의 식별자인 이 것은 무엇일까요?

> 정답 : ETag

ETag (cache 관련 태그)<br>
<br>

캐시의 검증을 위해 사용되는 자원의 식별자. 주로 자원의 해시값이 사용되나,<br>
마지막으로 수정된 시각, 혹은 버전 넘버를 사용하기도 합니다

<br>

## 동일 출처 정책으로 관련 내용이 아닌 것은?

1.  웹 보안의 기본 원칙이다.
2.  동일 출처면 전역객체에 접근이 불가능하다.
3.  http,https 는 서로 다른 출처이다.
4.  리소스의 출처가 웹페이지의 출처와 같으면 안전하다.

> 정답 : 2 번

<br>

## Content-Security-Policy 헤더의 내용으로 알맞은 것은?

1.  주로 프론트엔드 개발자가 사용하는 기법이다.
2.  요청에 포함 시켜야 하는 헤더이다.
3.  이 헤더를 이용하면 동일한 출처에 대한 리소스를 불러올수 있다.
4.  안전하게 리소스를 제공할 수 있다.

> 정답 : 4 번

보통 서버개발자가 사용하는 기법이다.<br>
응답에 포함 시켜야 하는 헤더,<br>
동일하지 않은 출처에 대한 리소스를 불러올지 말지 결정할 수 있다

<br>

## 한 도메인에서 로드되어 다른 도메인에 있는 리소스와 상호 작용하는 클라이언트 웹 애플리케이션에 대한 방법을 정의하는 표준은 무엇인가?

> 정답 : CORS

<br>

## JWT 의 내용으로 알맞지 않은 것은?

1.  토큰 안에 JSON 형식으로 정보를 저장함
2.  보안을 위해 서명 또는 암호화를 사용할 수 있다.
3.  최근 널리 사용되고 있는 쿠키-세션 형식의 표준
4.  필요한 모든 정보를 자체적으로 포함되어있다.

> 정답 : 3 번

쿠키-세션 형식의 표준이 아닌 토큰 형식의 표준

<br>

## 웹 브라우저 XMLHttpRequest 를 대체하기 위해 만들어진 새로운 HTTP Client 표준은 무엇인가?

> 정답 : Fetch API

<br>

## Cache 의 내용으로 알맞은 것은?

1.  인터넷상에서만 사용되고 있다.
2.  캐시는 주로 접근속도의 개선을 위해 데이터를 미리 복사해 놓는 임시 저장소이다.
3.  HTTP Cache 는 클라이언트에서 가져온 자원을 서버에 저장해 놓고 재사용한다.
4.  캐시 혹은 캐싱이라는 용어 자체는 특정 기술을 나타낸다.

> 정답 : 2 번

<br>

## GraphQL 의 내용과 관련이 없는 것은?

1.  REST API 를 대체하기 위해 만들어짐.
2.  서버에서는 GraphQL 질의를 해석하기 위해 별도의 해석기가 필요하다
3.  Amazon 에서 2015 년 공개한 데이터 질의 언어.
4.  클라이언트에서 필요한 데이터 구조를 GraphQL 언어로 정의한 후 질의할 수 있다

> 정답 : 3 번

amazon 이 아니라 facebook!

<br>

## 토큰 사용의 단점이 아닌 것은?

1.  쿠키와는 다르게, 클라이언트 개발자가 직접 토큰을 저장하고 관리해야 함
2.  토큰 유출에 대한 대비책이 필요
3.  CORS 관련 문제의 대응이 복잡하다
4.  적당히 짧은 길이를 유지해야함

> 정답 : 3 번

3 번은 쿠키에 대한 설명입니다.

<br>
